# 토스 러너스하이 2기 프로젝트 기획

> 작성일: 2025-12-17
> 목표: 한 달간의 성장 기록을 통한 토스 서버 개발자 면접 기회 확보

---

## 1. 현재 상황 분석

### 나의 프로필
- **경력**: 4년차 공공 SI/SM Java 개발자
- **현재 상태**: 프로젝트 투입 종료, 본사 대기
- **제약사항**:
  - 기존 프로젝트 소스 접근 불가 (폐쇄망/보안)
  - 처음부터 새로 시작해야 함
  - 한 달 기간 제한

### 러너스하이 핵심 평가 기준
러너스하이는 **"오직 한 달간의 경험만"** 평가한다.

| 질문 | 의미 |
|------|------|
| 왜 해당 기술을 적용해야 하는가? | 문제 인식 능력 |
| 왜 이 방법을 선택했는가? | 기술적 판단력 |
| 왜 문제가 발생했는가? | 문제 분석 능력 |
| 어떻게 해결할 것인가? | 해결 능력 |
| 어떻게 성장할 것인가? | 성장 마인드셋 |

### 1기 참가자로부터 배운 점
- 초기 계획: Kafka 도입, MSA화 등 거창한 목표
- 멘토링 후 변경: 내부 SDK 도입, 재발 이슈 방지, 자동화 등 실질적인 문제 해결
- **핵심**: 거창함보다 "깊은 고민과 문제 해결 과정"이 중요

---

## 2. 선택한 프로젝트 방향

### 옵션 A: SI 경험 기반 개발자 도구 ✅ 선택

#### 선택 이유
1. **재사용성**: 새 프로젝트 투입 시 바로 가져가서 적용 가능
2. **진정성**: 4년간의 SI 경험에서 나온 실제 Pain Point 해결
3. **스토리텔링**: "왜"를 설명하기 자연스러움
4. **기여 가치**: 나뿐만 아니라 다른 SI 개발자들에게도 도움

---

## 3. 확정 프로젝트: Code Flow Tracer ✅

### 프로젝트 개요
**레거시 코드 흐름 분석기** - API 엔드포인트부터 SQL까지의 호출 흐름을 자동 추적하고 문서화

```
[요청 URL: /api/user/list]
    ↓
[UserController.getList()]
    ↓
[UserService.findAll()]
    ↓
[UserDAO.selectUserList]
    ↓
[SQL: SELECT * FROM TB_USER WHERE...]
```

### 핵심 기능
1. **호출 흐름 추적**: Controller → Service → DAO → SQL
2. **iBatis XML 파싱**: SQL ID와 실제 쿼리 매핑
3. **문서화 출력**: 엑셀, 콘솔
4. **전자정부프레임워크 지원**: 레거시 SI 환경 특화

### UI 방식 결정 ✅

#### 1차: CLI (Week 1-2)
```bash
java -jar tracer.jar --path /project/src --url "/api/user/*" --format excel
```

#### 2차: Desktop GUI - Swing (Week 3)
```
┌─ Code Flow Tracer ─────────────────────────┐
│  프로젝트 경로: [                ] [찾기]  │
│  분석 대상:  ● URL 패턴  [/api/user/*    ] │
│  출력 형식:  [v] 콘솔  [v] 엑셀  [ ] MD    │
│  [분석 시작]                               │
│  ┌─ 결과 ────────────────────────────────┐ │
│  │ UserController.getList()              │ │
│  │   └→ UserService.findAll()            │ │
│  │        └→ UserDAO.selectUserList      │ │
│  └───────────────────────────────────────┘ │
│  [엑셀 저장]  [클립보드 복사]              │
└────────────────────────────────────────────┘
```

#### 왜 Web UI 대신 Desktop GUI인가?
| 구분 | Web UI | Desktop GUI (Swing) |
|------|--------|---------------------|
| 실행 | 서버 띄우고 브라우저 접속 | jar 더블클릭 |
| 폐쇄망 | △ 번거로움 | ◎ 최적 |
| 배포 | 서버 설정 필요 | jar 파일 하나 전달 |
| 의존성 | 브라우저 필요 | Java만 있으면 됨 |

**결론**: 폐쇄망 SI 환경에서는 **jar 하나로 실행 가능한 Desktop GUI가 최적**

#### 왜 Swing인가?
- JDK 기본 포함 → 추가 의존성 없음
- 레거시 Java 환경에서도 실행 가능
- 폐쇄망에서 jar 하나로 배포 가능
- JavaFX보다 가볍고 심플

---

## 4. Pain Point 분석 결과 ✅

### 도출된 핵심 Pain Point
1. **레거시 코드 흐름 파악의 어려움**
   - 분기가 많으면 헷갈림
   - API 호출부터 관련 소스 찾기가 번거로움

2. **반복적인 CRUD 코드 작성**
   - 매번 비슷한 패턴의 코드

3. **문서화의 부재**
   - 엑셀이나 문서로 정리되면 좋겠음
   - 인수인계 시 어려움

### SI 환경 특성
| 항목 | 내용 |
|------|------|
| 프레임워크 | 전자정부프레임워크 |
| Java 버전 | 1.7 |
| ORM | iBatis (MyBatis 아님) |
| DB | Oracle |
| 브라우저 | IE 호환성 중요 |
| 테스트 코드 | 없음 |
| 특이사항 | 폐쇄망, 풀스택 개발, 프로젝트마다 환경 상이 |

---

## 5. 기술 스택 ✅

### 개발 환경 (도구 자체)
| 구분 | 선택 | 이유 |
|------|------|------|
| Java | 17+ | 최신 문법 경험, Record/Pattern Matching 활용 |
| 빌드 | Gradle | 의존성 관리 편의 |
| 소스 파싱 | JavaParser | Java AST 분석 라이브러리 |
| XML 파싱 | JDOM2 | iBatis XML 파싱 |
| 엑셀 출력 | Apache POI | 엑셀 파일 생성 |
| GUI | Swing | JDK 기본 포함, 의존성 없음 |
| 패키징 | Shadow JAR | 단일 실행 파일 생성 |

### 분석 대상 (레거시 코드)
- 전자정부프레임워크 구조
- **Java 버전 무관** (1.4 ~ 21 모두 지원)
- iBatis/MyBatis XML
- Oracle SQL

> **참고**: JavaParser는 언어 레벨 설정으로 모든 Java 버전을 분석 가능.
> 도구는 Java 21에서 실행하면서 Java 1.7 코드도 분석할 수 있음.

### 테스트용 샘플 프로젝트
- [egovframe-simple-homepage-template](https://github.com/eGovFramework/egovframe-simple-homepage-template)
- Controller → Service → DAO → SQL 구조가 명확
- 전자정부프레임워크 공식 샘플
- 로컬 샘플: `code-flow-tracer/samples/` (직접 작성)

### 아키텍처별 지원 범위

| 패턴 | MVP 지원 | 향후 확장 |
|------|----------|----------|
| Controller → Service → DAO | ◎ 완벽 | - |
| 전자정부프레임워크 | ◎ 완벽 | - |
| Spring MVC | ◎ 완벽 | - |
| 헥사고날 아키텍처 | △ 기본 | ○ 가능 |
| 이벤트 기반 (@EventListener) | × | △ 부분적 |
| AOP (@Transactional) | × | △ 어노테이션만 |

> **MVP 전략**: 직접 메서드 호출에 집중, 구조는 확장 가능하게 설계

---

## 6. 한 달 실행 계획 ✅

```
Week 1: 설계 + 기본 파서 개발
├── 프로젝트 셋업 (Gradle, 의존성)
├── Java 소스 파싱 로직 (JavaParser)
├── Controller → Service → DAO 호출 추적
└── 매일 개발 일지 작성

Week 2: iBatis 파싱 + 출력
├── iBatis XML 파싱 (SQL ID 매핑)
├── 콘솔 출력 구현
├── 엑셀 출력 구현 (Apache POI)
└── CLI 인터페이스 완성

Week 3: GUI + 테스트
├── Swing GUI 개발
├── 테스트용 샘플 프로젝트 생성
├── 다양한 케이스 테스트
└── GitHub 공개 + README 작성

Week 4: 개선 + 회고
├── 피드백 반영 개선
├── 엣지 케이스 처리
├── 전체 과정 회고 정리
└── 러너스하이 경력기술서 작성
```

---

## 7. 성공 기준

### 러너스하이 제출용 경력기술서 목표
- [ ] 프로젝트 배경: 왜 이 도구가 필요한가?
- [ ] 기술 선택: 왜 이 기술 스택을 선택했는가?
- [ ] 문제 해결: 개발 중 마주친 문제와 해결 과정
- [ ] 성과: 정량적/정성적 성과 (사용자 피드백, 성능 개선 등)
- [ ] 성장: 이 프로젝트를 통해 배운 점

### 최소 MVP 기준
- [ ] 핵심 기능 1개 이상 동작
- [ ] 실제 배포 완료
- [ ] README 및 사용 가이드 문서화
- [ ] 1명 이상의 사용자 피드백

---

## 8. 러너스하이 스토리 (경력기술서 초안)

### 프로젝트를 시작한 이유
> "4년간 공공 SI/SM 프로젝트를 하면서 가장 힘들었던 것은 레거시 코드 파악이었습니다.
> 특히 분기가 많은 코드에서 하나의 API 흐름을 따라가려면 여러 파일을 오가며
> 수동으로 추적해야 했습니다. 이 과정을 자동화하면 인수인계 시간을 크게
> 줄일 수 있겠다고 생각했습니다."

### 기술 선택의 이유

**왜 Java 17인가?**
> "분석 도구는 최신 Java로 개발하여 Record, Pattern Matching 등
> 모던 Java 문법을 경험하고자 했습니다. 단, 분석 대상은 Java 1.7
> 레거시 코드를 지원합니다."

**왜 Swing인가?**
> "Web UI 대신 Desktop GUI를 선택한 이유는 폐쇄망 SI 환경 때문입니다.
> jar 파일 하나로 배포하여 별도 서버 없이 실행할 수 있어야 했습니다.
> Swing은 JDK에 기본 포함되어 추가 의존성 없이 어디서든 실행 가능합니다."

**왜 JavaParser인가?**
> "정규식 기반 파싱은 복잡한 코드에서 오류가 많습니다.
> AST(Abstract Syntax Tree) 기반의 JavaParser를 사용하여
> 정확한 메서드 호출 관계를 추출할 수 있었습니다."

### 마주친 문제와 해결 (작성 예정)
- [ ] 문제 1: ???
- [ ] 해결: ???
- [ ] 배운 점: ???

### 성과 (작성 예정)
- [ ] 정량적 성과: 코드 분석 시간 단축률
- [ ] 정성적 성과: 사용자 피드백

---

## 9. 참고 자료

- [토스 러너스하이 1기 후기](https://velog.io/@gkdis6/토스-러너스하이-1기)
- [SI에서 서비스 회사 이직 후기](https://okky.kr/articles/534691)
- [토스 2024 NEXT 개발자 챌린지](https://toss.im/career/next-developer-2024)
- [백엔드 포트폴리오 작성법](https://spartacodingclub.kr/blog/2024-backend-developer-portfolio)

---

## 10. 다음 단계

### 즉시 해야 할 것
1. [x] Pain Point 분석 ✅
2. [x] 프로젝트 방향 확정 ✅
3. [x] UI 방식 결정 (CLI + Swing GUI) ✅
4. [x] 기술 스택 결정 ✅
5. [ ] **Gradle 프로젝트 생성**
6. [ ] **테스트용 샘플 레거시 코드 작성**
7. [ ] **JavaParser 학습 및 POC**

### Week 1 세부 목표
- [ ] 프로젝트 초기 셋업
- [ ] 간단한 Java 파일 파싱 테스트
- [ ] Controller 클래스에서 @RequestMapping 추출
- [ ] 메서드 호출 관계 추적 기본 로직
- [ ] 매일 개발 일지 작성 시작

---

*이 문서는 프로젝트 진행에 따라 지속적으로 업데이트됩니다.*
